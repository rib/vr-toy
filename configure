#!/usr/bin/env python

import glob
import platform
import os
import subprocess
import sys
import argparse

#try:
#    import multiprocessing.synchronize
#    gyp_parallel_support = True
#except ImportError:
#    gyp_parallel_support = False

gyp_parallel_support = False

script_dir = os.path.dirname(__file__)
src_dir = os.path.normpath(script_dir)
output_dir = os.path.join(os.path.abspath(src_dir), 'out')

sys.path.insert(0, os.path.join(src_dir, 'build', 'gyp', 'pylib'))
try:
    import gyp
except ImportError:
    print('GYP build tool not found. Optionally install under build/gyp with:')
    print('  git clone https://chromium.googlesource.com/external/gyp build/gyp')
    sys.exit(42)

if "CYGWIN" in platform.system():
    sys.exit("Don't run with Cygwin Python, use a Python for Windows release")

def host_arch():
    machine = platform.machine()
    if machine == 'i386': return 'ia32'
    if machine == 'x86_64': return 'x64'
    if machine == 'AMD64': return 'x64'
    if machine.startswith('arm'): return 'arm'
    return machine  # Return as-is and hope for the best.

def pkg_config_exists(pkg_name):
    if platform.system() == "Linux":
        try:
            subprocess.check_call(["pkg-config", "--exists", pkg_name])
            return True
        except:
            return False
    else:
        return False

def pkg_config_get(pkg_name, arg):
    if platform.system() == "Linux":
        return subprocess.check_output(["pkg-config", arg, pkg_name])
    else:
        return ""

def pkg_config_variable(pkg_name, variable):
    return subprocess.check_output(["pkg-config", "--variable=" + variable, pkg_name]).strip()

def run_gyp(args):
    rc = gyp.main(args)
    if rc != 0:
        print('Error running GYP')
        sys.exit(rc)

def add_option(parser, name, opt):
    if not opt["enabled"]:
        enable_help = "Enable " + opt["help"]
        disable_help = argparse.SUPPRESS
    else:
        enable_help = argparse.SUPPRESS
        disable_help = "Disable " + opt["help"]
    hyphen_name = name.replace('_', '-')
    parser.add_argument("--enable-" + hyphen_name, dest="enable_" + name, action="store_true", default=opt["enabled"], help=enable_help)
    parser.add_argument("--disable-" + hyphen_name, dest="enable_" + name, action="store_false", default=not opt["enabled"], help=disable_help)


parser = argparse.ArgumentParser()

parser.add_argument("--prefix",
                    help="install architecture-independent files in PREFIX",
                    default="/usr/local")
parser.add_argument("--host",
                    help="cross-compile to build programs to run on HOST")
parser.add_argument("--enable-shared", action='store_true',
                    help="build shared libraries")

subst = {
        "CG_DEFINES": "",
        "RIG_VERSION": "2",
        "U_MAJOR_VERSION": "53",
        "U_MINOR_VERSION": "1",
        "U_PATCHLEVEL_VERSION": "1",
}
enabled = {}
options = {
        "_": {
            "enabled": True,
            "conditions": [
                [ 'OS=="win"', {
                    "public_defines": { "CG_HAS_GL_SUPPORT", "CG_HAS_WIN32_SUPPORT", "CG_HAS_WGL_SUPPORT" },
                    "libraries": [ '-lopengl32.lib' ],
                }],
            ]
        },
        "debug": {
            "help": "debug support",
            "enabled": False,
            "defines": [ "RIG_ENABLE_DEBUG", "C_DEBUG", "CG_GL_DEBUG", "CG_OBJECT_DEBUG", "CG_ENABLE_DEBUG" ]
        },
#        "opencv": {
#            "help": "OpenCV support",
#            "enabled": True,
#            "pkg-config": "opencv >= 3.0.0",
#            "defines": [ "USE_OPENCV" ]
#        },
#        "oculus_rift": {
#            "help": "OculusRift support",
#            "enabled": True,
#            "defines": [ "ENABLE_OCULUS_RIFT" ],
#        },
        "ffmpeg": {
            "help": "ffmpeg support",
            "enabled": True,
            "defines": [ "USE_FFMPEG" ],
            "pkg-config": "libavcodec libavformat libavutil libswscale libswresample",
        },
        "alsa": {
            "platforms": [ "linux" ],
            "help": "Alsa audio support",
            "enabled": True,
            "pkg-config": "alsa",
            "defines": [ "USE_ALSA" ]
        },
        "uv": {
            "help": "libuv support",
            "enabled": True,
            "pkg-config": "libuv",
            "public_defines": { "CG_HAS_UV_SUPPORT" },
            "defines": [ "USE_UV" ]
        },
        "glib": {
            "help": "GLib support",
            "enabled": False,
            "pkg-config": "glib-2.0",
            "public_defines": { "CG_HAS_GLIB_SUPPORT" },
            "defines": [ "USE_GLIB" ]
        },
        "x11": {
            "platforms": [ "linux" ],
            "pkg-config": "x11 xdamage xcomposite xfixes xext xrandr xkbcommon-x11 x11-xcb xext",
            "public_defines": { "CG_HAS_XLIB_SUPPORT", "CG_HAS_X11_SUPPORT" },
            "ldflags": [ "-lXi" ],
            "defines": { "USE_X11" },
        },
        "glx": {
            "platforms": [ "linux" ],
            "requires": { "x11" }, #TODO check
            "help": "GLX support",
            "enabled": True,
            "pkg-config": "gl",
            "public_defines": { "CG_HAS_GLX_SUPPORT", "CG_HAS_GL_SUPPORT", "CG_HAS_XLIB_SUPPORT", "CG_HAS_X11_SUPPORT" },
        },
        "egl": {
            "platforms": [ "linux" ],
            "help": "EGL support",
            "enabled": True,
            "pkg-config": "egl",
            "public_defines": { "CG_HAS_EGL_SUPPORT" },
        },
        "egl_wayland": {
            "platforms": [ "linux" ],
            "help": "Wayland EGL support",
            "enabled": True,
            "pkg-config": "wayland-egl",
            "public_defines": { "CG_HAS_EGL_PLATFORM_WAYLAND_SUPPORT" },
        },
        "egl_kms": {
            "platforms": [ "linux" ],
            "help": "Kernel Mode Setting EGL support",
            "enabled": False,
            "pkg-config": "egl gbm libdrm",
            "public_defines": { "CG_HAS_EGL_PLATFORM_KMS_SUPPORT" },
        },
        "egl_xlib": {
            "platforms": [ "linux" ],
            "help": "XLib EGL support",
            "enabled": True,
            "pkg-config": "egl x11",
            "public_defines": { "CG_HAS_EGL_PLATFORM_XLIB_SUPPORT" },
        },
        "sdl": {
            "platforms": [ "linux" ],
            "help": "SDL 2.0 support",
            "enabled": False,
            "pkg-config": "sdl2",
            "public_defines": { "CG_HAS_SDL_SUPPORT" },
        },
        "gles2": {
            "platforms": [ "linux" ],
            "help": "GLES 2.0 support",
            "enabled": True,
            "pkg-config": "glesv2",
            "public_defines": { "CG_HAS_GLES2_SUPPORT" },
        },
        "ncurses": {
            "platforms": [ "linux" ],
            "help": "ncurses debug console",
            "enabled": False,
            "pkg-config": "ncursesw",
            "defines": [ "USE_NCURSES" ],
        },
}

output = {
        "rig/cglib/cglib/cg-defines.h",
        "rig/icu/source/common/unicode/uvernum.h",
        "rig/rig/rig-defines.h",
}

# Lazily nabbed from http://stackoverflow.com/questions/7204805/dictionaries-of-dictionaries-merge
def merge(a, b, path=None):
    "merges b into a"
    if path is None: path = []
    for key in b:
        if key in a:
            if isinstance(a[key], dict) and isinstance(b[key], dict):
                merge(a[key], b[key], path + [str(key)])
            elif a[key] == b[key]:
                pass # same leaf value
            else:
                raise Exception('Conflict at %s' % '.'.join(path + [str(key)]))
        else:
            a[key] = b[key]
    return a

if platform.system() == "Windows":
    OS = "win"
elif platform.system() == "Linux":
    OS = "linux"

cond_vars = {}
cond_vars['OS'] = OS

def add_conditionals(_dict):
    if 'conditions' in _dict:
        conditions = _dict['conditions']
        del _dict['conditions']

        for cond in conditions:
            expr = cond[0]
            if eval(expr, cond_vars):
                _dict = merge(_dict, cond[1])
            elif len(cond) >= 3:
                _dict = merge(_dict, cond[2])

    for key in _dict:
        child = _dict[key]
        if isinstance(child, dict):
            add_conditionals(child)

    return _dict


options = add_conditionals(options)

# Defaults...
for name, opt in options.items():
    if name == "conditions":
        continue
    if "defines" not in opt:
        opt["defines"] = []
    if "includes" not in opt:
        opt["includes"] = []
    if "ldflags" not in opt:
        opt["ldflags"] = []
    if "enabled" not in opt:
        if OS == "linux" and "pkg-config" in opt:
            opt["enabled"] = pkg_config_exists(opt["pkg-config"])
        else:
            opt["enabled"] = False

for name, opt in options.items():
    if "platforms" in opt:
        if OS not in opt['platforms']:
            opt['enabled'] = False

for name, opt in options.items():
    if "help" in opt:
        add_option(parser, name, opt)

opt_args = parser.parse_args()
opt_args_dict = vars(opt_args)

if opt_args.host != None and "emscripten" in opt_args.host:
    use_libuv = False
else:
    use_libuv = True

#options['_']["defines"].append("ICU_DATA_DIR=\"" + pkg_config_variable("icu-uc", "prefix") + "/share\"")
options['_']["defines"].append("ICU_DATA_DIR=\"" + opt_args.prefix + "/share\"")
options['_']["defines"].append("RIG_BIN_DIR=\"" + opt_args.prefix + "/bin\"")

for name, opt in options.items():
    if "enable_" + name in opt_args_dict:
        if opt_args_dict["enable_" + name]:
            print("explicit enable:" + name)
            if OS == "linux" and "pkg-config" in opt:
                if not pkg_config_exists(opt["pkg-config"]):
                    sys.exit(opt["pkg-config"] + " required for enabling " + name + " support is missing")
            opt["enabled"] = True
            enabled[name] = opt
        else:
            print("explicit disable:" + name)
            opt["enabled"] = False
    else:
        print("default " + name)
        if opt["enabled"]:
            enabled[name] = opt

if OS == "linux":
    for name, opt in enabled.items():
        if "pkg-config" in opt:
            cflags = pkg_config_get(opt["pkg-config"], "--cflags")
            tokens = cflags.split()
            if len(tokens):
                for tok in tokens:
                    if tok[:2] == "-I":
                        opt["includes"].append(tok[2:])
                    elif tok[:2] == "-D":
                        opt["defines"].append(tok[2:])
            ldflags = pkg_config_get(opt["pkg-config"], "--libs")
            tokens = ldflags.split()
            if len(tokens):
                for tok in tokens:
                    opt["ldflags"].append(tok)


gyp_config = open("config.gypi", "w")

gyp_config.write("{\n")
gyp_config.write("  'variables': {\n")

for name, opt in options.items():
    if opt["enabled"]:
        gyp_config.write("    'enable_" + name + "%': '1',\n")
    else:
        gyp_config.write("    'enable_" + name + "%': '0',\n")

if opt_args.host != None and "emscripten" in opt_args.host:
    gyp_config.write("    'OS%': 'emscripten',\n")

if OS == "win":
    gyp_config.write("    'os_posix%': '0',\n")
else:
    gyp_config.write("    'os_posix%': '1',\n")

if use_libuv:
    gyp_config.write("    'enable_uv%': '1',\n")
else:
    gyp_config.write("    'enable_uv%': '0',\n")

gyp_config.write("    'host_arch%': '" + host_arch() + "',\n")
gyp_config.write("    'target_arch%': '" + host_arch() + "',\n")

gyp_config.write("    'is_nodejs_build%': '1',\n")

gyp_config.write("  },\n")


# FIXME: we shouldn't be setting up target_defaults that
# will affect *all* targets. We should just setup helper
# variables that the various .gyp files can reference
gyp_config.write("""
  'target_defaults': {
    'include_dirs': [
""")

for name, opt in enabled.items():
    if "includes" in opt:
        gyp_config.write("      # " + name + " includes...\n")
        for include in opt["includes"]:
            gyp_config.write("      '" + include + "',\n")

gyp_config.write("""
    ],
    'defines': [
""")
for name, opt in enabled.items():
    if "defines" in opt:
        gyp_config.write("      # " + name + " defines...\n")
        for define in opt["defines"]:
            gyp_config.write("      '" + define + "',\n")

gyp_config.write("""
    ],
    'link_settings': {
      'libraries': [
""")

for name, opt in enabled.items():
    if "libraries" in opt:
        gyp_config.write("        # " + name + " libs...\n")
        for lib in opt["libraries"]:
            gyp_config.write("        '" + lib + "',\n")

gyp_config.write("""
      ]
    }
  }
""")
gyp_config.write("}\n")

for name, opt in enabled.items():
    if "public_defines" in opt:
        defines = opt["public_defines"]
        for define in defines:
            subst["CG_DEFINES"] = subst["CG_DEFINES"] + "#define " + define + "\n"

gyp_args = []

gyp_args.append(os.path.join(src_dir, 'vr-toy.gyp'))

if OS == "win":
    os.environ['CC'] = "clang-cl.exe"
    os.environ['CXX'] = "clang-cl.exe"
    os.environ['GYP_MSVS_VERSION'] = "2015"
    gyp_args.append('-DMSVS_VERSION=2015') # XXX: HACK to appease openssl.gypi
    gyp_args.append('--no-parallel')
    gyp_args.append('-Dtarget_arch=' + host_arch())
    gyp_args.append('-Dos_posix=0')
else:
    gyp_args.append('-Dos_posix=1')

gyp_args.extend('-f ninja'.split())
#gyp_args.extend('-f make'.split())

#gyp_args.append('--debug=all')
#gyp_args.append('--check')

gyp_args.extend(['-I', "config.gypi"])
gyp_args.extend(['-I', "common.gypi"])

options_fn = os.path.join(src_dir, 'options.gypi')
if os.path.exists(options_fn):
    gyp_args.extend(['-I', options_fn])

gyp_args.append('--depth=' + src_dir)

gyp_args.append('-Dlibrary=shared_library')

if opt_args.enable_shared:
    gyp_args.append('-Drig_library=shared_library')

if OS == "win":
    gyp_args.append('-DOS=win')

if use_libuv:
    subst["CG_DEFINES"] = subst["CG_DEFINES"] + "#define CG_HAS_UV_SUPPORT\n"

gyp_args.extend(['-Dis_nodejs_build=0'])

gyp_config.close()

for file in output:
    file_contents = None

    with open(file + ".in", 'r') as fp:
        file_contents = fp.read()

    for key, val in subst.items():
        file_contents = file_contents.replace("@" + key + "@", val)

    try:
        fp = open(file, 'r')
        current_contents = fp.read()
    except:
        current_contents = ""
    finally:
        fp.close()

    if current_contents == file_contents:
        print(file + " unchanged")
    else:
        with open(file, 'w') as fp:
            print("creating " + file)
            fp.write(file_contents)
print("")

gyp_args = list(gyp_args)
print("Running gyp:")
print("$ gyp " + " ".join(gyp_args))
run_gyp(gyp_args)

#print("Running node-gyp:")
#print("$ node-gyp configure")
#subprocess.check_call(["node-gyp", "configure"])

if "ninja" in gyp_args:
    print("\n\nReady to build:")
    print("$ make")
